Moon Unit
=========

A randomized testing framework for Lua, inspired by Haskell's Quickcheck.

The code for Moon Unit is released under the MIT License.

Please send comments, suggestions, bug reports, limericks, etc. to
scott@silentbicycle.com .


Building and installation
-------------------------

The only dependency is Luiz Henrique de Figueiredo's [lrandom][]
library, which is used because it has better statistical properties, and
because (unlike math.random) its results are consistent cross-platform.
Note that the May 2009 version is recommended. (The current version in
the LuaRocks repository is old, and has an incompatible interface.)

[lrandom]: http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#lrandom

This module is written in pure Lua, so there's no need to build it. You
can copy it into your Lua module path (e.g. /usr/local/share/lua/5.1/)
if you want it to be loadable system-wide.


Overview
--------

    require "moonunit"
    
    local t = moonunit.new()
    local t = moonunit.new{ verbose="error_only" }
    t:test("flipcoin", 
           function(x) return x end, 
           false)
    
Example output:

    flipcoin:       100 trials, seed    1244918064 .......... FAIL (+49, -51, s0, e0)

This runs a test 100 times which generates a random boolean, and
succeeds when the result == true. The type of "false" tells it to
generate a bool. ("error_only" prevents displaying every failure.)

For further usage examples, see test.lua.


Tester object
-------------

The constructor, moonunit.new(), takes an optional table argument, which
checks for the following values:

  + count (100):         number of tests to run
  + skips (50):          # of tests that can be skipped without error
  + verbose (false):     default level of verbosity, see below
  + progress (count/10): how many steps to go before showing progress
  + out (stdout):        file for logging output
  + seed_limit (1e13):   upper bound on seeds to use
  + seed (os.time()):    starting seed, modulo seed_limit
  + show_progress:       hook for logging, see below


### Verbosity:

  + true:          print pass/fail/etc. for every test
  + false:         show . for progress and error/failure details
  + "error_only":  same as false, but don't show failure details.


### Show_progress

Logging is done by a function which is given nine arguments:

  + self:   the tester
  + log:    the logging function, which itself takes (self, ...)
  + seed:   the current seed
  + trials: number of trials run so far
  + pass:   passes
  + fail:   failures
  + skip:   trials skipped
  + err:    number of trials ended by an error


Tester object interface:
------------------------

+ log(...):        output string.format(...) to the log file
+ show_progress(several args): see below
+ set_seed(s):     set the current seed
+ test(...):       Run the actual test.

The function is run for every test case, using random arguments
specified by the subsequent arguments to t:test. Any value besides
false, nil, or "skip" is a success; false/nil are failure, and "skip"
skips this trial. Execution can also be stopped by error(result), i.e.,
error("pass"), error("fail"), error("skip"). Any other error is reported
as an actual error. t:test() returns true if all tests pass, nil otherwise.

Arguments after the first function specify how to randomly generate the
arguments given to it:

  + boolean:  return true or false
  + number n: return 0 <= x < n, or -n <= x < n if n is signed.
              If n has a decimal component (other than .0), then
              a random value < 1.0 will be added.
  + string:   Generate by pattern.
              "10 %l" means 10 lowercase letters, "10,30 [aeiou]" means
              between 10 and 30 vowels, inclusive, etc. The standard
              Lua pattern escapes (e.g. %l, %s) are used.
  + function: Call with a RNG and use the returned value.
  + table or udata: Same as function, but get it from v.__random,
              so it can be defined in the metatable.

For example,
    t:test("foo", function(a, b, c, d) 
                     return a and b > 0 
                        and string.len(c) > 10 and #d > 3
                  end,
           false, 
           -20.1, 
           "5,20 %l",
           function(r)
              local t = {}
              for i=1,r:get_int(10) do t[#t+1] = "X" end
              return t
           end)

Generates a bool, a number -20 <= x < 20, a 5-20 character string,
and a list with 1-9 cells containing "X".


RNG object
----------

An RNG object is passed as the first argument to user-supplied test
functions. It provides the following interface:

+ get_bool():             get a random bool
+ get_float(bound):       get a random float 0 <= x < bound
+ get_float(low, high):   get a random float low <= x < high
+ get_int(bound):         get a random int 0 <= x < bound
+ get_int(low, high):     get a random int low <= x < high
+ get_string(spec):       get a random string, according to spec
+ set_seed(s):            set the new random seed to s


Bugs, issues, etc.
----------------

+ Running tests with a large $count temporarily eats up a lot of memory,
  since every seed used is stored in a table (to ensure $count unique
  tests). For example, count of 1,000,000 uses approx. 85 MB.
+ The name sucks.
+ It still needs to be tested with userdata.
