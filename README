lunatest
========

A randomized testing framework for Lua, inspired by Haskell's Quickcheck.

The code for lunatest is released under the MIT License.

Please send comments, suggestions, bug reports, etc. to
<vokes.s@gmail.com> .


Building and installation
-------------------------

The only dependency is Luiz Henrique de Figueiredo's [lrandom][]
library, which is used because it has better guaranteed statistical
properties than math.random and its results are consistent across
platforms. The May 2009 version or newer is recommended. (The version
currently in the main LuaRocks repository is from 2007, and has an
incompatible interface.)

[lrandom]: http://www.tecgraf.puc-rio.br/~lhf/ftp/lua/#lrandom

This module is written in pure Lua, so there's no need to build it. You
can copy it into your Lua module path (e.g. /usr/local/share/lua/5.1/)
if you want it to be loadable system-wide.


Overview
--------

    require "lunatest"
    
    local t = lunatest.new()
    local t = lunatest.new{ verbose="error_only" }
    t:test("flipcoin", 
           function(x) return x end, 
           false)
    
Example output:

    flipcoin:       100 trials, seed    1244918064 .......... FAIL (+49, -51, s0, e0)

This runs 100 trials, which generate a random boolean and succeed when
the result is true. The type of "false" tells it to generate a boolean,
and setting verbose to "error_only" suppresses details for every
failure.

If lunatest finds failures or errors, you can add their seeds directly
to the test specification, and they will always be included in
subsequent trials. (This can be used for simple regression testing.)

For further usage examples, see test.lua.

*****

Tester object
-------------

The constructor, lunatest.new(), takes an optional table argument. It
checks for the following values, otherwise using the listed defaults:

  + count (100):         number of tests to run
  + skips (50):          # of tests that can be skipped without error
  + verbose (false):     default level of verbosity, see below
  + progress (count/10): how many steps to go before showing progress
  + out (stdout):        file for logging output
  + seed_limit (1e13):   upper bound on seeds to use
  + seed (os.time()):    starting seed, modulo seed_limit
  + show_progress:       hook for logging, see below


### Levels of verbosity:

  + false:         show . for progress, details for errors/failures only
  + "error_only":  same as false, but don't show failure details.
  + true:          print pass/fail/etc. for every test


### Show_progress

Logging is done by a function which is given nine arguments:

  + self:   the tester
  + log:    the logging function, which itself takes (self, ...)
  + seed:   the current seed
  + trials: number of trials run so far
  + pass:   passes
  + fail:   failures
  + skip:   trials skipped
  + error:  number of trials ended by an error


Tester object interface:
------------------------

+ log(...):        output string.format(...) to the log file
+ show_progress(several args): see above
+ set_seed(s):     set the current seed
+ test(see below): Run the actual test.


### The test method

test takes the following arguments, in order:

+ a label (optional)
+ a list of seeds to always test (optional)
+ the trial function (required)
+ a list of one or more argument specifiers (required)

The trial function is run once for every trial, using random arguments
specified by the subsequent arguments to t:test. Any value besides
false, nil, or "skip" is considered a success; false/nil are failure,
and "skip" skips this trial. Execution can also be stopped by
error(result), i.e., error("pass"), error("fail"), error("skip"). Any
other error is reported as an actual error. 

### Argument specifiers

The values after the trial function specify how to randomly generate
its arguments:

  + boolean:  return true or false
  + number n: return 0 <= x < n, or -n <= x < n if n is signed.

    If n has a decimal component (other than .0), then
    a random value < 1.0 will be added.
  + string:   Generate by pattern.

    "10 %l" means 10 lowercase letters, "10,30 [aeiou]" means
    between 10 and 30 vowels, inclusive, etc. The standard
    Lua pattern escapes (e.g. %l, %s) are used.
  + function: Called with an RNG, uses the returned value.
  + table or udata: Same as function, but calls value.__random(RNG),
    so it can be defined in the metatable.

test returns a boolean of whether all arguments passed, followed by the
pass, fail, skip, and error counts.


### Example

    local t = lunatest.new()
    t:test("foo", { 316874885789, 1245507938 },
                  function(a, b, c, d) 
                     return a and b > 0 
                        and string.len(c) > 10 and #d > 3
                  end,
           false, 
           -20.1, 
           "5,20 %l",
           function(r)
              local t = {}
              for i=1,r:get_int(10) do t[#t+1] = "X" end
              return setmetatable(t, { __tostring=function(self) 
                                                     return table.concat(self)
                                                  end })
           end)

This generates a bool, a number -20 <= x < 20, a 5-20 character string,
and a list with 1-9 cells containing "X". (__tostring is used when
displaying arguments in failed trials.) The seeds 316874885789 and
1245507938 are always tested, and then there are $count random trials.


Random number generator object
----------

An RNG object is passed to the trial function. It provides the following
interface:

+ get_bool():             get a random bool
+ get_choice(array):      get a random choice from the array
+ get_float(bound):       get a random float 0 <= x < bound
+ get_float(low, high):   get a random float low <= x < high
+ get_int(bound):         get a random int 0 <= x < bound
+ get_int(low, high):     get a random int low <= x < high
+ get_string(spec):       get a random string, according to spec
+ set_seed(s):            set the new random seed to s


Bugs, issues, etc.
----------------

+ As tests track every seed used to ensure $count unique seeds, running
  tests with a very large trial count will temporarily use a lot of
  memory. For example, 1,000,000 trials uses approx. 85 MB.
